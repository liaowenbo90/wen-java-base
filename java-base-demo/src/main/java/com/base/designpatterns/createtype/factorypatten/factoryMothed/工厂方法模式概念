模式问题： 轻松方便地构造对象实例，不必关心对象的细节和复杂过程
解决方案： 建立一个工厂创建对象
工厂方法模式：
 （多态工厂模式、虚拟构造器模式）通过定义父类负责创建对象的公共接口,子类负责生成具体的对象
     一个工厂无法创建一个系列的车（一个系列再分小系列）,单独分出多个具体工厂,具体工厂类创建具体产品,
     但系列工厂还是抽象的，只定具体工厂生产
    作用：将类的实例化延迟到工厂子类（具体工厂）,由子类决定实例哪一个类
    解决问题：工厂一旦需要生产新的产品要修改工厂类方法逻辑,违背 开放关闭原则
    特点：
        一个抽象产品类，可以派生出多个具体产品类
        一个抽象工厂类，可以派生出多个具体工厂类
        每个具体工厂类只能创建一个具体产品类实例
    角色：
        抽象产品：具体产品父类,具体产品的公共接口
        抽象工厂：具体工厂的父类,具体工厂的公共接口
        具体产品：抽象产品的子类，生产的具体产品
        具体工厂：抽象工厂的子类,实现FactoryMethod工厂方法创建产品的实例
    使用步骤
        步骤1： 创建抽象工厂类，定义具体工厂的公共接口；
        步骤2： 创建抽象产品类 ，定义具体产品的公共接口；
        步骤3： 创建具体产品类（继承抽象产品类） & 定义生产的具体产品；
        步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；
        步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例
    优点：
        新增一点产品时，只需要新增新的具体产品和相应工厂子类即可
        保留了简单工厂的优点同时, 让扩展变得简单，让继承变得可行,增加了多态的体现
    应用场景：
        当一个类不知道它所需要的对象时
            工厂方法中，客户端不需要知道具体产品类名,只需要知道所对应的工厂
        当一个类希望通过其子类来指定创建对象
            工厂方法,抽象工厂只需要提供一个创建产品的接口,而由其子类来确定具体要创建的对象





























