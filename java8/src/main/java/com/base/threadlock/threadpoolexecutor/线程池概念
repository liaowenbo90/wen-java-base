问题：
    如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。
    可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的
    系统资源要比处理实际的用户请求的时间和资源更多。
优点：
    降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
    提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
    提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
应用场景：
    单个任务处理时间比较短
    需要处理的任务数量很多

降低资源消耗、提高响应速度、提高线程的可管理性


Runnable接口和Callable接口的区别
    两者的区别在于 Runnable 接口不会返回结果但是 Callable 接口可以返回结果。
    工具类Executors可以实现Runnable对象和Callable对象之间的相互转换。

执行execute()方法和submit()方法的区别
    execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；
    submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功

创建线程池
    Executors  ThreadPoolExecutor

    FixedThreadPool ： 该方法返回一个固定线程数量的线程池。
    SingleThreadExecutor： 方法返回一个只有一个线程的线程池
    CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。
    Atomic 原子类
    Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。
    使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。