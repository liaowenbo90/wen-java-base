GC算法（垃圾收集器）
	主要回收java堆和方法区，其它的会随线程生、灭，实现自动清理
		对象存活判断：
			引用计数：每个对象都有一个引用计算属性，引用+1，释放-1，
				无法解决相互引用的问题。
			可达性分析：从GC Roots 向下搜索，搜索所走过的路为引用链，当一个
				对象到GC没有任何引用链相连时，则证明此对象不可用，不可达
			GC Roots 包括：
				栈中引用对象
				方法区中类静态属性实体引用对象
				访法区中常量引用对象
				本地方法栈中JNI引用对象
		
		垃圾收集算法（方法论）
			标记-清除算法（基础算法）
				缺点：效率问题、空间问题（产生大量的内存碎片）
				优点：适合老年代存活高的、没有额外空间分配的
					标记：标记出所有需要回收的对象
					清除：统一回收所有标记的对象
			复制算法
				缺点：内存减小一半，复制长生存对象效率慢，
				优点：合适大批对象死去少部分存活
				将内存分为两块，每次只使用一块，当一个满了，则复制存活的对象
					到另一块，清理当前块
			标记-压缩算法：
				优点：适合老年代存活高的、没有额外空间分配的
				让所有存活的对象都向一端移动，然后清理掉端边界以外的内存
			分代收集算法：
				把新生代和老年代区分来回收
		垃圾收集器（具体实现）
			串行收集器（serial）
				特点：古老、稳定、效率高
				对象：新生代、老年代
				过程：会产生较长停顿，一个线程回收
					用的方法：新生代用复制算法、老年代标记-压缩 
					参数控制：-XX:+UseSerialGC  串行收集器
			parNew收集器：（串行多线程版）
				对象：新生代并行、老年代串行
				过程：新生代复制、老年代标记-压缩
				参数控制：-XX:+UseParNewGC  ParNew收集器，-XX:ParallelGCThreads 限制线程数量
			parallel收集器：（平行收集器）
				类似于parNew ,关注吞吐量
				参数：-XX:+UseParallelGC  使用Parallel收集器+ 老年代串行
			parallelOld收集器
				-XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行
			CMS收集器
				以最短回收停顿为目标，重视响应速度
				算法：标记-清除
				优点：并发收集、低停顿
				缺点：产生大量空间碎片、并发降低吞吐量
				控制参数：
					-XX:+UseConcMarkSweepGC  使用CMS收集器
					-XX:+ UseCMSCompactAtFullCollection Full GC
			GL收集器
				特点：
					空间整合：收集器采用标记整理算法，不产生空间碎片
					可预测停顿：降低停顿时间，建立可停顿模型
				过程：会重新划分堆分成多个大小相等的独立区域，当新生区到达一定比例会开始收集
					标记阶段
					Root Region Scanning: 回收survivor区
					Concurrent Marking:整个堆并发标记
					remark:再标记
					copy/clean up:多线程清除失活对象
					
			