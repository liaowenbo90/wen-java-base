1、类的加载概念
    将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内
    ，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构.
    类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的
    数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口，
    简单点:将class文件读到内中，在椎创建class对象，将class对象的数据结构存放在方法区并提供访问
2、类的生命周期（加载过程）
    加载-》验证-》准备-》解析-》初始化-》使用-》卸载
    加载：查找并加臷类的二进制数据
    验证：确保被加载的类的正确性
    准备：为类的静态变量分配内存
    解析：把类中的符号引用转换为直接引用（直接引用就是直接指向目标指针、相对偏移量
    或是一个间接定位到目标的句柄）
    初始化：为静态变量赋予初始值 如实例、静态变量、反射
    结束生命周期：正常执行结束、报错、操作系统出错

3类加载器
    父类加载器不是通过继承关系实现的，而是通过组合实现的
    启动类加载器：Bootstrap ClassLoader 负责加载存放在JDK/jre/lib，能被虚拟机识别的
    类库，开发者不能用
    扩展类加载器：Extension ClassLoader 负责加载jdk/jre/lib/ext 的类库，开发者可以直接
    使用
    应用程序类加载器：Application ClassLoader ,负责加载用户类路径所指定的类，开发者
    可以直接用的，没有定义则是默认类加载器

    自定义加载器：字节传输进行加密

    应用程序者是由这三种类加载器互相配合进行加载的，自带JVM的CLassLoad只是懂得从本地、
    文件系统加载标准的java class 文件

JVM类加载机制
    全盘负责：当一个类加载器负责加载某个Class时，该类所依赖的和引用的其它Class也将、
    由该类加载
    父类委托：先让父类加载试图加载该类，只有父类加载器无法加载时才尝试从自己的类路径
    中加载该类
    缓存机制：保证所有加载的类都会被缓存，需要用的时候先从缓存中读，没有才会读取二进
    制数据，并将其转换成Class类，。。

    Class.forName()与ClassLoader.loadClass区别
    Class.forName() : 将类的.class文件加载到jvm，进行解释，执行类中的static块
    ClassLoader.loadClass(): 只干一件事 ，就是将.class加载到jvm,不会执行static中的内容
    Class.forName(name,initalize，loader) 带参数可控制static块

4、双亲委派机制
    工作流程：当一个类加载器收到请求时，自已先不会加载而把请求发送给父类，
            当顶级父类加载不到，子加载器才会尝试自己加载
    意义：
        1、系统类防止内存中出现多份同样的字节码
        2、保证java程序安全稳定运行



对象的创建过程
    类加载检查过程：new 对象的时候，检查常量池中是有否在，没有存执行执类的加载
    分配内存：两种，指针碰撞、空闲列表，保证线程安全
    初始化零值：内存空间初始化为零
    设置对象头：头信息设置
    设置对象头执行init方法：从程序员看来，所有都为0，刚刚开始








